-- =====================================================
-- Migration: Topic Mock Rankings System
-- Description: Sistema de ranking para tests tipo Mock
-- Date: 2025-11-03
-- =====================================================

-- =====================================================
-- 1. Crear tabla topic_mock_rankings
-- =====================================================

CREATE TABLE IF NOT EXISTS "public"."topic_mock_rankings" (
  "id" BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  "topic_id" BIGINT NOT NULL REFERENCES "public"."topic"("id") ON DELETE CASCADE,
  "user_id" BIGINT NOT NULL REFERENCES "public"."users"("id") ON DELETE CASCADE,

  -- Estadísticas del usuario en este topic
  "first_score" NUMERIC NOT NULL,
  "best_score" NUMERIC NOT NULL,
  "attempts" INTEGER DEFAULT 1 NOT NULL,
  "last_attempt_date" TIMESTAMPTZ NOT NULL,
  "first_attempt_date" TIMESTAMPTZ NOT NULL,

  -- Posición en el ranking (1 = mejor)
  "rank_position" INTEGER,

  -- Auditoría
  "created_at" TIMESTAMPTZ DEFAULT now() NOT NULL,
  "updated_at" TIMESTAMPTZ DEFAULT now() NOT NULL,

  -- Constraint único: un usuario solo puede tener una entrada por topic
  CONSTRAINT "unique_topic_user_ranking" UNIQUE ("topic_id", "user_id")
);

ALTER TABLE "public"."topic_mock_rankings" OWNER TO "postgres";

COMMENT ON TABLE "public"."topic_mock_rankings" IS
'Almacena el ranking de usuarios para cada topic Mock basado en la primera puntuación obtenida';

COMMENT ON COLUMN "public"."topic_mock_rankings"."first_score" IS
'Primera puntuación obtenida por el usuario en este topic (inmutable, define el ranking)';

COMMENT ON COLUMN "public"."topic_mock_rankings"."best_score" IS
'Mejor puntuación obtenida por el usuario en este topic (se actualiza con cada intento)';

COMMENT ON COLUMN "public"."topic_mock_rankings"."attempts" IS
'Número total de intentos del usuario en este topic';

COMMENT ON COLUMN "public"."topic_mock_rankings"."first_attempt_date" IS
'Fecha del primer intento (inmutable)';

COMMENT ON COLUMN "public"."topic_mock_rankings"."rank_position" IS
'Posición en el ranking (1 = mejor first_score). Se calcula automáticamente';

-- =====================================================
-- 2. Índices para optimización
-- =====================================================

-- Índice para ordenar ranking por topic y first_score (usado para el ranking)
CREATE INDEX "idx_rankings_topic_first_score"
ON "public"."topic_mock_rankings"("topic_id", "first_score" DESC);

-- Índice adicional para best_score (consultas de mejores puntuaciones)
CREATE INDEX "idx_rankings_topic_best_score"
ON "public"."topic_mock_rankings"("topic_id", "best_score" DESC);

-- Índice para búsquedas por usuario
CREATE INDEX "idx_rankings_user"
ON "public"."topic_mock_rankings"("user_id");

-- Índice para ordenar por posición
CREATE INDEX "idx_rankings_topic_position"
ON "public"."topic_mock_rankings"("topic_id", "rank_position");

-- Índice para tests finalizados con scores (útil para consultas de ranking)
CREATE INDEX IF NOT EXISTS "idx_user_tests_finalized_score"
ON "public"."user_tests"("finalized", "score" DESC, "created_at" DESC)
WHERE "finalized" = true AND "score" IS NOT NULL;

-- =====================================================
-- 3. Función para recalcular rankings de un topic
-- =====================================================

CREATE OR REPLACE FUNCTION "public"."recalculate_topic_rankings"(p_topic_id BIGINT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER  -- Run with owner's privileges to bypass RLS
SET search_path = public
AS $$
BEGIN
  -- Recalcula las posiciones (rank_position) para todos los usuarios de este topic
  -- Ordena por first_score DESC (puntuación de la primera vez)
  -- En caso de empate, el que lo hizo primero tiene mejor posición

  WITH ranked_users AS (
    SELECT
      id,
      ROW_NUMBER() OVER (ORDER BY first_score DESC, first_attempt_date ASC) as new_rank
    FROM "public"."topic_mock_rankings"
    WHERE topic_id = p_topic_id
  )
  UPDATE "public"."topic_mock_rankings" tmr
  SET
    rank_position = ru.new_rank,
    updated_at = now()
  FROM ranked_users ru
  WHERE tmr.id = ru.id
    AND tmr.topic_id = p_topic_id;

END;
$$;

ALTER FUNCTION "public"."recalculate_topic_rankings"(BIGINT) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."recalculate_topic_rankings"(BIGINT) IS
'Recalculates ranking positions for a specific topic. Runs as SECURITY DEFINER to bypass RLS.';

-- =====================================================
-- 4. Función para actualizar ranking cuando se completa un test Mock
-- =====================================================

CREATE OR REPLACE FUNCTION "public"."update_ranking_on_mock_complete"()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER  -- Run with owner's privileges to bypass RLS
SET search_path = public
AS $$
DECLARE
  v_topic_id BIGINT;
  v_topic_type_level TEXT;
  v_current_best_score NUMERIC;
  v_current_attempts INTEGER;
  v_should_recalculate BOOLEAN := false;
BEGIN
  -- Only process finalized tests with score
  IF NEW.finalized IS NOT TRUE OR NEW.score IS NULL THEN
    RETURN NEW;
  END IF;

  -- Verify that topic_ids has at least one element
  IF array_length(NEW.topic_ids, 1) IS NULL OR array_length(NEW.topic_ids, 1) = 0 THEN
    RETURN NEW;
  END IF;

  -- Take the first topic_id (assuming a Mock test has a single topic)
  v_topic_id := NEW.topic_ids[1];

  -- Skip virtual topics (e.g., generated study tests with id=-1)
  IF NOT EXISTS (SELECT 1 FROM "public"."topic" WHERE id = v_topic_id) THEN
    RETURN NEW;
  END IF;

  -- Check if the topic is Mock type
  SELECT tt.level INTO v_topic_type_level
  FROM "public"."topic" t
  JOIN "public"."topic_type" tt ON t.topic_type_id = tt.id
  WHERE t.id = v_topic_id;

  -- Only process if topic is Mock (skip if NULL or not 'Mock')
  IF v_topic_type_level IS NULL OR v_topic_type_level != 'Mock' THEN
    RETURN NEW;
  END IF;

  -- Obtener el ranking actual del usuario para este topic (si existe)
  SELECT best_score, attempts INTO v_current_best_score, v_current_attempts
  FROM "public"."topic_mock_rankings"
  WHERE topic_id = v_topic_id AND user_id = NEW.user_id;

  -- Si no existe entrada, crear una nueva (primer intento)
  IF v_current_best_score IS NULL THEN
    -- Primera vez: first_score y best_score son iguales
    INSERT INTO "public"."topic_mock_rankings" (
      topic_id,
      user_id,
      first_score,
      best_score,
      attempts,
      first_attempt_date,
      last_attempt_date
    ) VALUES (
      v_topic_id,
      NEW.user_id,
      NEW.score,  -- first_score (inmutable desde ahora)
      NEW.score,  -- best_score (puede mejorar después)
      1,
      NEW.created_at,  -- first_attempt_date (inmutable)
      NEW.created_at   -- last_attempt_date
    );
    -- Recalcular porque hay un nuevo participante
    v_should_recalculate := true;

  ELSE
    -- Actualizar entrada existente (intentos posteriores)
    -- first_score y first_attempt_date NO se tocan (son inmutables)

    IF NEW.score > v_current_best_score THEN
      -- Actualizar best_score si mejora
      UPDATE "public"."topic_mock_rankings"
      SET
        best_score = NEW.score,
        attempts = v_current_attempts + 1,
        last_attempt_date = NEW.created_at,
        updated_at = now()
      WHERE topic_id = v_topic_id AND user_id = NEW.user_id;
      -- NO recalcular porque first_score no cambió (el ranking no se ve afectado)

    ELSE
      -- Solo actualizar attempts y fecha, sin cambios en scores
      UPDATE "public"."topic_mock_rankings"
      SET
        attempts = v_current_attempts + 1,
        last_attempt_date = NEW.created_at,
        updated_at = now()
      WHERE topic_id = v_topic_id AND user_id = NEW.user_id;
      -- NO recalcular porque nada cambió en el ranking
    END IF;
  END IF;

  -- Recalcular rankings SOLO si hay un nuevo usuario (porque first_score es inmutable)
  IF v_should_recalculate THEN
    PERFORM "public"."recalculate_topic_rankings"(v_topic_id);
  END IF;

  RETURN NEW;
END;
$$;

ALTER FUNCTION "public"."update_ranking_on_mock_complete"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."update_ranking_on_mock_complete"() IS
'Updates ranking when a user completes a Mock test. Runs as SECURITY DEFINER to bypass RLS. Skips virtual topics (id=-1) and non-Mock topics. Detects Mock tests by topic type. Only recalculates when there is a new participant (first_score is immutable).';

-- =====================================================
-- 5. Trigger en user_tests
-- =====================================================

CREATE TRIGGER "trg_update_ranking_on_mock_complete"
AFTER INSERT OR UPDATE OF finalized, score
ON "public"."user_tests"
FOR EACH ROW
EXECUTE FUNCTION "public"."update_ranking_on_mock_complete"();

COMMENT ON TRIGGER "trg_update_ranking_on_mock_complete" ON "public"."user_tests" IS
'Dispara la actualización del ranking cuando se finaliza un test Mock';

-- =====================================================
-- 6. Función para actualizar updated_at
-- =====================================================

CREATE OR REPLACE FUNCTION "public"."update_rankings_updated_at"()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

ALTER FUNCTION "public"."update_rankings_updated_at"() OWNER TO "postgres";

CREATE TRIGGER "trigger_update_rankings_updated_at"
BEFORE UPDATE ON "public"."topic_mock_rankings"
FOR EACH ROW
EXECUTE FUNCTION "public"."update_rankings_updated_at"();

-- =====================================================
-- 7. Permisos RLS (Row Level Security)
-- =====================================================

-- Habilitar RLS en topic_mock_rankings
ALTER TABLE "public"."topic_mock_rankings" ENABLE ROW LEVEL SECURITY;

-- Política: usuarios autenticados pueden leer todos los rankings
CREATE POLICY "rankings_select_policy"
ON "public"."topic_mock_rankings"
FOR SELECT
TO authenticated
USING (true);

-- Política: usuarios anónimos pueden leer rankings (para preview)
CREATE POLICY "rankings_select_anon_policy"
ON "public"."topic_mock_rankings"
FOR SELECT
TO anon
USING (true);

-- Política: service_role puede hacer todo
CREATE POLICY "rankings_all_service_role"
ON "public"."topic_mock_rankings"
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- =====================================================
-- 8. Grants de permisos
-- =====================================================

GRANT SELECT ON TABLE "public"."topic_mock_rankings" TO anon;
GRANT SELECT ON TABLE "public"."topic_mock_rankings" TO authenticated;
GRANT ALL ON TABLE "public"."topic_mock_rankings" TO service_role;

GRANT USAGE ON SEQUENCE "public"."topic_mock_rankings_id_seq" TO anon;
GRANT USAGE ON SEQUENCE "public"."topic_mock_rankings_id_seq" TO authenticated;
GRANT ALL ON SEQUENCE "public"."topic_mock_rankings_id_seq" TO service_role;

GRANT EXECUTE ON FUNCTION "public"."recalculate_topic_rankings"(BIGINT) TO service_role;
GRANT EXECUTE ON FUNCTION "public"."update_ranking_on_mock_complete"() TO service_role;
GRANT EXECUTE ON FUNCTION "public"."update_rankings_updated_at"() TO service_role;
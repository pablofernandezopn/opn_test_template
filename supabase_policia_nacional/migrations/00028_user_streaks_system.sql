-- =====================================================
-- User Streaks System
-- =====================================================
-- Sistema de rachas para motivar el estudio diario
-- Incluye tracking automático y widget semanal
-- =====================================================

-- =====================================================
-- 1. Añadir campos de racha a la tabla users
-- =====================================================
ALTER TABLE public.users
ADD COLUMN IF NOT EXISTS current_streak integer DEFAULT 0 NOT NULL,
ADD COLUMN IF NOT EXISTS longest_streak integer DEFAULT 0 NOT NULL,
ADD COLUMN IF NOT EXISTS last_activity_date date,
ADD COLUMN IF NOT EXISTS streak_updated_at timestamp with time zone;

COMMENT ON COLUMN public.users.current_streak IS 'Racha actual en días consecutivos de actividad';
COMMENT ON COLUMN public.users.longest_streak IS 'Récord histórico de racha más larga del usuario';
COMMENT ON COLUMN public.users.last_activity_date IS 'Última fecha donde el usuario completó al menos un test';
COMMENT ON COLUMN public.users.streak_updated_at IS 'Timestamp de última actualización de la racha';

-- =====================================================
-- 2. Crear tabla para actividad diaria detallada
-- =====================================================
CREATE TABLE IF NOT EXISTS public.user_daily_activity (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    activity_date date NOT NULL,
    tests_completed integer DEFAULT 0 NOT NULL,
    questions_answered integer DEFAULT 0 NOT NULL,
    correct_answers integer DEFAULT 0 NOT NULL,
    total_time_seconds integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,

    CONSTRAINT user_daily_activity_unique_user_date UNIQUE(user_id, activity_date)
);

ALTER TABLE public.user_daily_activity OWNER TO postgres;

COMMENT ON TABLE public.user_daily_activity IS 'Registro diario de actividad del usuario para cálculo de rachas y estadísticas';
COMMENT ON COLUMN public.user_daily_activity.activity_date IS 'Fecha de la actividad (sin hora)';
COMMENT ON COLUMN public.user_daily_activity.tests_completed IS 'Número de tests completados ese día';
COMMENT ON COLUMN public.user_daily_activity.questions_answered IS 'Total de preguntas respondidas ese día';
COMMENT ON COLUMN public.user_daily_activity.correct_answers IS 'Número de respuestas correctas ese día';
COMMENT ON COLUMN public.user_daily_activity.total_time_seconds IS 'Tiempo total dedicado en segundos ese día';

-- Índices para optimizar consultas
CREATE INDEX IF NOT EXISTS idx_user_daily_activity_user_date
    ON public.user_daily_activity(user_id, activity_date DESC);

CREATE INDEX IF NOT EXISTS idx_user_daily_activity_date
    ON public.user_daily_activity(activity_date DESC);

-- =====================================================
-- 3. Función para calcular rachas de un usuario
-- =====================================================
CREATE OR REPLACE FUNCTION "public"."calculate_user_streak"(p_user_id bigint)
RETURNS TABLE(
    current_streak integer,
    longest_streak integer,
    last_activity_date date
) AS $$
DECLARE
    v_current_streak integer := 0;
    v_longest_streak integer := 0;
    v_date_cursor date;
    v_prev_date date;
    v_last_activity date;
    v_consecutive_count integer := 0;
    v_max_consecutive integer := 0;
    v_first_iteration boolean := true;
BEGIN
    -- Obtener fechas únicas donde el usuario completó tests (finalized = true)
    -- Ordenadas de más reciente a más antigua
    FOR v_date_cursor IN
        SELECT DISTINCT DATE(created_at) as activity_date
        FROM public.user_tests
        WHERE user_id = p_user_id
          AND finalized = true
        ORDER BY activity_date DESC
    LOOP
        IF v_first_iteration THEN
            -- Primera iteración - establecer la última actividad
            v_last_activity := v_date_cursor;
            v_consecutive_count := 1;
            v_prev_date := v_date_cursor;
            v_first_iteration := false;
        ELSIF v_prev_date - v_date_cursor = 1 THEN
            -- Día consecutivo (diferencia de 1 día)
            v_consecutive_count := v_consecutive_count + 1;
            v_prev_date := v_date_cursor;
        ELSE
            -- Se rompió la racha
            IF v_consecutive_count > v_max_consecutive THEN
                v_max_consecutive := v_consecutive_count;
            END IF;
            -- Reiniciar contador para la siguiente racha
            v_consecutive_count := 1;
            v_prev_date := v_date_cursor;
        END IF;
    END LOOP;

    -- Verificar la última racha acumulada
    IF v_consecutive_count > v_max_consecutive THEN
        v_max_consecutive := v_consecutive_count;
    END IF;

    -- La racha actual solo cuenta si el último día fue hoy o ayer
    -- (damos 1 día de gracia para no perder la racha)
    IF v_last_activity IS NOT NULL AND v_last_activity >= CURRENT_DATE - INTERVAL '1 day' THEN
        v_current_streak := v_consecutive_count;
    ELSE
        v_current_streak := 0;
    END IF;

    v_longest_streak := GREATEST(v_max_consecutive, 0);

    RETURN QUERY SELECT v_current_streak, v_longest_streak, v_last_activity;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION "public"."calculate_user_streak"(bigint) IS 'Calcula la racha actual y récord histórico basándose en user_tests finalizados';

-- =====================================================
-- 4. Función para obtener actividad de los últimos 7 días
-- =====================================================
CREATE OR REPLACE FUNCTION "public"."get_week_activity"(p_user_id bigint)
RETURNS TABLE(
    day_of_week integer,
    day_name text,
    activity_date date,
    has_activity boolean,
    is_today boolean,
    tests_completed integer,
    questions_answered integer
) AS $$
BEGIN
    RETURN QUERY
    WITH week_dates AS (
        -- Generar los últimos 7 días (incluyendo hoy)
        SELECT
            generate_series(
                CURRENT_DATE - INTERVAL '6 days',
                CURRENT_DATE,
                INTERVAL '1 day'
            )::date as date
    ),
    user_activity AS (
        SELECT
            uda.activity_date as activity_date,
            uda.tests_completed as tests_completed,
            uda.questions_answered as questions_answered
        FROM public.user_daily_activity uda
        WHERE uda.user_id = p_user_id
          AND uda.activity_date >= CURRENT_DATE - INTERVAL '6 days'
    )
    SELECT
        EXTRACT(DOW FROM wd.date)::integer as day_of_week,
        CASE EXTRACT(DOW FROM wd.date)::integer
            WHEN 0 THEN 'D'  -- Domingo
            WHEN 1 THEN 'L'  -- Lunes
            WHEN 2 THEN 'M'  -- Martes
            WHEN 3 THEN 'M'  -- Miércoles
            WHEN 4 THEN 'J'  -- Jueves
            WHEN 5 THEN 'V'  -- Viernes
            WHEN 6 THEN 'S'  -- Sábado
        END as day_name,
        wd.date::date as activity_date,
        (ua.activity_date IS NOT NULL) as has_activity,
        (wd.date = CURRENT_DATE) as is_today,
        COALESCE(ua.tests_completed, 0) as tests_completed,
        COALESCE(ua.questions_answered, 0) as questions_answered
    FROM week_dates wd
    LEFT JOIN user_activity ua ON ua.activity_date::date = wd.date::date
    ORDER BY wd.date;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION "public"."get_week_activity"(bigint) IS 'Retorna la actividad de los últimos 7 días para el widget de racha';

-- =====================================================
-- 5. Trigger para actualizar actividad diaria automáticamente
-- =====================================================
CREATE OR REPLACE FUNCTION "public"."update_daily_activity_and_streak"()
RETURNS TRIGGER AS $$
DECLARE
    v_activity_date date;
    v_streak_info record;
BEGIN
    -- Solo procesar si el test fue finalizado (nuevo o actualizado a finalizado)
    IF NEW.finalized = true AND (OLD IS NULL OR OLD.finalized = false) THEN
        v_activity_date := DATE(NEW.created_at);

        -- Insertar o actualizar actividad diaria
        INSERT INTO public.user_daily_activity (
            user_id,
            activity_date,
            tests_completed,
            questions_answered,
            correct_answers,
            total_time_seconds
        ) VALUES (
            NEW.user_id,
            v_activity_date,
            1,
            NEW.total_answered,
            NEW.right_questions,
            COALESCE(NEW.total_time_seconds, 0)
        )
        ON CONFLICT (user_id, activity_date)
        DO UPDATE SET
            tests_completed = user_daily_activity.tests_completed + 1,
            questions_answered = user_daily_activity.questions_answered + NEW.total_answered,
            correct_answers = user_daily_activity.correct_answers + NEW.right_questions,
            total_time_seconds = user_daily_activity.total_time_seconds + COALESCE(NEW.total_time_seconds, 0),
            updated_at = now();

        -- Recalcular racha del usuario
        SELECT * INTO v_streak_info
        FROM "public"."calculate_user_streak"(NEW.user_id);

        -- Actualizar campos de racha en users
        UPDATE public.users
        SET
            current_streak = v_streak_info.current_streak,
            longest_streak = GREATEST(longest_streak, v_streak_info.longest_streak),
            last_activity_date = v_streak_info.last_activity_date,
            streak_updated_at = now()
        WHERE id = NEW.user_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_daily_activity_and_streak ON public.user_tests;

CREATE TRIGGER trigger_update_daily_activity_and_streak
    AFTER INSERT OR UPDATE ON public.user_tests
    FOR EACH ROW
    EXECUTE FUNCTION "public"."update_daily_activity_and_streak"();

COMMENT ON FUNCTION "public"."update_daily_activity_and_streak"() IS 'Actualiza automáticamente la actividad diaria y recalcula rachas cuando se finaliza un test';

-- =====================================================
-- 6. Vista para estadísticas de racha
-- =====================================================
CREATE OR REPLACE VIEW "public"."user_streak_stats" AS
SELECT
    u.id as user_id,
    u.username,
    u.current_streak,
    u.longest_streak,
    u.last_activity_date,
    u.streak_updated_at,
    CASE
        WHEN u.last_activity_date = CURRENT_DATE THEN true
        ELSE false
    END as completed_today,
    CASE
        WHEN u.last_activity_date >= CURRENT_DATE - INTERVAL '1 day' THEN 'active'
        WHEN u.last_activity_date >= CURRENT_DATE - INTERVAL '7 days' THEN 'inactive_recent'
        ELSE 'inactive'
    END as streak_status,
    CASE
        WHEN u.current_streak >= 30 THEN 'legend'
        WHEN u.current_streak >= 14 THEN 'champion'
        WHEN u.current_streak >= 7 THEN 'warrior'
        WHEN u.current_streak >= 3 THEN 'beginner'
        ELSE 'novice'
    END as streak_badge
FROM public.users u
WHERE u.deleted = false;

COMMENT ON VIEW "public"."user_streak_stats" IS 'Vista con estadísticas de racha y badges para gamificación';

-- =====================================================
-- 7. Función para obtener estadísticas completas de racha
-- =====================================================
CREATE OR REPLACE FUNCTION "public"."get_user_streak_data"(p_user_id bigint)
RETURNS json AS $$
DECLARE
    v_result json;
BEGIN
    SELECT json_build_object(
        'user_id', u.id,
        'current_streak', u.current_streak,
        'longest_streak', u.longest_streak,
        'last_activity_date', u.last_activity_date,
        'streak_updated_at', u.streak_updated_at,
        'completed_today', (u.last_activity_date = CURRENT_DATE),
        'week_activity', (
            SELECT json_agg(week_data)
            FROM "public"."get_week_activity"(p_user_id) week_data
        )
    )
    INTO v_result
    FROM public.users u
    WHERE u.id = p_user_id;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION "public"."get_user_streak_data"(bigint) IS 'Retorna todos los datos de racha del usuario en formato JSON, incluyendo actividad semanal';

-- =====================================================
-- 8. Migración de datos históricos
-- =====================================================
-- Poblar user_daily_activity con datos históricos existentes
INSERT INTO public.user_daily_activity (
    user_id,
    activity_date,
    tests_completed,
    questions_answered,
    correct_answers,
    total_time_seconds,
    created_at,
    updated_at
)
SELECT
    user_id,
    DATE(created_at) as activity_date,
    COUNT(*) as tests_completed,
    SUM(total_answered) as questions_answered,
    SUM(right_questions) as correct_answers,
    SUM(COALESCE(total_time_seconds, 0)) as total_time_seconds,
    MIN(created_at) as created_at,
    MAX(updated_at) as updated_at
FROM public.user_tests
WHERE finalized = true
GROUP BY user_id, DATE(created_at)
ON CONFLICT (user_id, activity_date) DO NOTHING;

-- Actualizar rachas de todos los usuarios existentes
DO $$
DECLARE
    v_user record;
    v_streak_info record;
BEGIN
    FOR v_user IN SELECT id FROM public.users WHERE deleted = false
    LOOP
        -- Calcular racha para cada usuario
        SELECT * INTO v_streak_info
        FROM "public"."calculate_user_streak"(v_user.id);

        -- Actualizar campos de racha
        UPDATE public.users
        SET
            current_streak = COALESCE(v_streak_info.current_streak, 0),
            longest_streak = COALESCE(v_streak_info.longest_streak, 0),
            last_activity_date = v_streak_info.last_activity_date,
            streak_updated_at = now()
        WHERE id = v_user.id;
    END LOOP;

    RAISE NOTICE 'Rachas actualizadas para todos los usuarios';
END $$;

-- =====================================================
-- 9. Índices adicionales para rendimiento
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_users_current_streak
    ON public.users(current_streak DESC)
    WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_users_longest_streak
    ON public.users(longest_streak DESC)
    WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_user_tests_finalized_date
    ON public.user_tests(user_id, created_at DESC)
    WHERE finalized = true;

-- =====================================================
-- Fin de migración 00028_user_streaks_system.sql
-- =====================================================

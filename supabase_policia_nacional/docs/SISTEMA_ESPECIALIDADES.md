 # Sistema de Especialidades (Specialties)

## Descripción General

El sistema de especialidades añade un nivel adicional de jerarquía entre academias y el contenido educativo, permitiendo que cada academia tenga múltiples programas o categorías de estudio independientes.

## Concepto

**Jerarquía**:
```
Academia (ej: Policía Nacional)
  └── Especialidad (ej: Escala Básica)
      ├── Topics específicos
      ├── Preguntas específicas
      ├── Alumnos específicos
      └── Sistema de membresías independiente
  └── Especialidad (ej: Escala Ejecutiva)
      ├── Topics específicos
      ├── Preguntas específicas
      ├── Alumnos específicos
      └── Sistema de membresías independiente
```

## Casos de Uso Real

### Ejemplo: Policía Nacional
- **Academia**: Policía Nacional
  - **Especialidad**: Escala Básica
    - Membresía: Premium Escala Básica (nivel 4)
    - Topics: Legislación Básica, Psicotécnicos Nivel 1...
    - Alumnos: 500 estudiantes
  - **Especialidad**: Escala Ejecutiva
    - Membresía: Premium Escala Ejecutiva (nivel 3)
    - Topics: Derecho Penal Avanzado, Gestión Policial...
    - Alumnos: 200 estudiantes

### Ejemplo: Guardia Civil
- **Academia**: Guardia Civil
  - **Especialidad**: Escala de Cabos y Guardias
  - **Especialidad**: Escala de Oficiales
  - **Especialidad**: Escala de Suboficiales

## Arquitectura

### Tabla Principal: `specialties`

```sql
CREATE TABLE specialties (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    academy_id BIGINT NOT NULL,              -- Academia propietaria
    name VARCHAR(255) NOT NULL,              -- Nombre: "Escala Básica"
    slug VARCHAR(100) NOT NULL,              -- URL-friendly: "escala-basica"
    description TEXT,
    icon_url TEXT,                           -- Icono/imagen representativa
    color_hex VARCHAR(7),                    -- Color temático (#FF5733)
    display_order INTEGER DEFAULT 0,         -- Orden de aparición
    is_active BOOLEAN DEFAULT true,          -- Si está activa
    is_default BOOLEAN DEFAULT false,        -- Si es la especialidad por defecto
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT fk_specialties_academy
        FOREIGN KEY (academy_id)
        REFERENCES academies(id) ON DELETE RESTRICT,

    CONSTRAINT specialty_name_length
        CHECK (LENGTH(TRIM(name)) > 0),

    CONSTRAINT specialty_slug_format
        CHECK (slug ~ '^[a-z0-9_-]+$'),

    CONSTRAINT unique_specialty_slug_per_academy
        UNIQUE (academy_id, slug),

    CONSTRAINT unique_specialty_name_per_academy
        UNIQUE (academy_id, name),

    CONSTRAINT one_default_per_academy
        UNIQUE (academy_id, is_default)
        WHERE is_default = true
);

CREATE INDEX idx_specialties_academy_id ON specialties(academy_id);
CREATE INDEX idx_specialties_active ON specialties(academy_id, is_active) WHERE is_active = true;
CREATE INDEX idx_specialties_order ON specialties(academy_id, display_order);
```

### Tablas Modificadas

Las siguientes tablas necesitan agregar `specialty_id`:

| Tabla | Cambio | Comportamiento |
|-------|--------|----------------|
| `users` | `specialty_id BIGINT` | Usuario pertenece a una especialidad |
| `topic` | `specialty_id BIGINT` | Topic pertenece a una especialidad |
| `questions` | Hereda de `topic` | Pregunta pertenece indirectamente a especialidad |
| `membership_levels` | `specialty_id BIGINT` | Membresía específica de especialidad |
| `user_memberships` | Hereda de `membership_levels` | Usuario suscrito a membresía de especialidad |
| `challenge` | `specialty_id BIGINT` | Challenge asociado a una especialidad |

**Nota**: `cms_users` (editores/tutores) NO están limitados por especialidades y pueden gestionar todo el contenido de su academia.

## Cambios Detallados por Tabla

### 1. Tabla `users`

```sql
ALTER TABLE users
ADD COLUMN specialty_id BIGINT,
ADD CONSTRAINT fk_users_specialty
    FOREIGN KEY (specialty_id)
    REFERENCES specialties(id) ON DELETE RESTRICT;

-- Índice para búsquedas
CREATE INDEX idx_users_specialty_id ON users(specialty_id);
CREATE INDEX idx_users_academy_specialty ON users(academy_id, specialty_id);
```

**Comportamiento**:
- Un usuario pertenece a **una especialidad** de su academia
- Si `specialty_id` es NULL, el usuario tiene acceso a contenido general de la academia
- Al cambiar de especialidad, pierde acceso al contenido de la especialidad anterior

### 2. Tabla `cms_users`

**No se modifica** - Los editores/tutores tienen acceso completo a todo el contenido de su academia, sin limitación por especialidades.

**Comportamiento**:
- Un editor puede gestionar **todas las especialidades** de su academia
- No hay restricción de acceso por especialidad
- Los editores gestionan el contenido según su `academy_id`

### 3. Tabla `topic`

```sql
ALTER TABLE topic
ADD COLUMN specialty_id BIGINT,
ADD CONSTRAINT fk_topic_specialty
    FOREIGN KEY (specialty_id)
    REFERENCES specialties(id) ON DELETE RESTRICT;

-- Índice compuesto para filtrado eficiente
CREATE INDEX idx_topic_academy_specialty ON topic(academy_id, specialty_id);
CREATE INDEX idx_topic_specialty_enabled ON topic(specialty_id, enabled) WHERE enabled = true;
```

**Comportamiento**:
- Un topic pertenece a **una especialidad**
- Si `specialty_id` es NULL, es contenido compartido entre todas las especialidades
- Las preguntas heredan automáticamente la especialidad de su topic

### 4. Tabla `membership_levels`

```sql
ALTER TABLE membership_levels
ADD COLUMN specialty_id BIGINT,
ADD CONSTRAINT fk_membership_specialty
    FOREIGN KEY (specialty_id)
    REFERENCES specialties(id) ON DELETE RESTRICT;

-- Índice para búsquedas
CREATE INDEX idx_membership_specialty ON membership_levels(specialty_id);
CREATE INDEX idx_membership_academy_specialty ON membership_levels(specialty_id, is_active)
WHERE is_active = true;
```

**Comportamiento**:
- Una membresía puede ser específica de una especialidad
- Si `specialty_id` es NULL, es membresía general de la academia
- Ejemplo:
  - Membresía "Premium Escala Básica" → `specialty_id = 1`
  - Membresía "Premium Escala Ejecutiva" → `specialty_id = 2`
  - Membresía "Premium General" → `specialty_id = NULL`

### 5. Tabla `challenge`

```sql
ALTER TABLE challenge
ADD COLUMN specialty_id BIGINT,
ADD CONSTRAINT fk_challenge_specialty
    FOREIGN KEY (specialty_id)
    REFERENCES specialties(id) ON DELETE RESTRICT;

CREATE INDEX idx_challenge_specialty ON challenge(specialty_id);
```

**Comportamiento**:
- Un challenge puede estar asociado a una especialidad
- Hereda la especialidad del topic de la pregunta reportada

## Funciones y Triggers

### 1. Función: Asignar Especialidad por Defecto

```sql
CREATE OR REPLACE FUNCTION assign_default_specialty()
RETURNS TRIGGER AS $$
DECLARE
    default_specialty_id BIGINT;
BEGIN
    -- Si no tiene specialty_id asignado
    IF NEW.specialty_id IS NULL AND NEW.academy_id IS NOT NULL THEN
        -- Buscar especialidad por defecto de la academia
        SELECT id INTO default_specialty_id
        FROM specialties
        WHERE academy_id = NEW.academy_id
          AND is_default = true
          AND is_active = true
        LIMIT 1;

        -- Si existe, asignar
        IF default_specialty_id IS NOT NULL THEN
            NEW.specialty_id := default_specialty_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar a users
CREATE TRIGGER trg_users_assign_specialty
BEFORE INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION assign_default_specialty();

-- Aplicar a topics
CREATE TRIGGER trg_topic_assign_specialty
BEFORE INSERT ON topic
FOR EACH ROW
EXECUTE FUNCTION assign_default_specialty();
```

### 2. Función: Validar Especialidad pertenece a Academia

```sql
CREATE OR REPLACE FUNCTION validate_specialty_belongs_to_academy()
RETURNS TRIGGER AS $$
DECLARE
    specialty_academy_id BIGINT;
BEGIN
    -- Si tiene specialty_id, validar que pertenezca a su academy_id
    IF NEW.specialty_id IS NOT NULL AND NEW.academy_id IS NOT NULL THEN
        SELECT academy_id INTO specialty_academy_id
        FROM specialties
        WHERE id = NEW.specialty_id;

        -- Validar coincidencia
        IF specialty_academy_id IS NULL OR specialty_academy_id != NEW.academy_id THEN
            RAISE EXCEPTION 'La especialidad (%) no pertenece a la academia (%)',
                NEW.specialty_id, NEW.academy_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar a todas las tablas relevantes
CREATE TRIGGER trg_users_validate_specialty
BEFORE INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION validate_specialty_belongs_to_academy();

CREATE TRIGGER trg_topic_validate_specialty
BEFORE INSERT OR UPDATE ON topic
FOR EACH ROW
EXECUTE FUNCTION validate_specialty_belongs_to_academy();

CREATE TRIGGER trg_membership_validate_specialty
BEFORE INSERT OR UPDATE ON membership_levels
FOR EACH ROW
EXECUTE FUNCTION validate_specialty_belongs_to_academy();
```

### 3. Trigger de Sincronización Auth

**Nota**: La función `sync_auth_users_to_cms()` ya existe y no necesita modificación para el sistema de especialidades, ya que los `cms_users` no tienen restricción por especialidad.

Los usuarios finales (`users`) sí reciben automáticamente la especialidad por defecto mediante el trigger `trg_users_assign_specialty`.

## Queries Comunes

### 1. Obtener Especialidades de una Academia

```sql
SELECT
    s.id,
    s.name,
    s.slug,
    s.description,
    s.icon_url,
    s.color_hex,
    s.is_default,
    COUNT(DISTINCT t.id) as total_topics,
    COUNT(DISTINCT u.id) as total_users
FROM specialties s
LEFT JOIN topic t ON t.specialty_id = s.id
LEFT JOIN users u ON u.specialty_id = s.id
WHERE s.academy_id = 1
  AND s.is_active = true
GROUP BY s.id
ORDER BY s.display_order, s.name;
```

### 2. Obtener Topics de una Especialidad

```sql
SELECT
    t.id,
    t.topic_name,
    t.description,
    t.is_premium,
    t.total_questions,
    tt.topic_type_name,
    tt.level
FROM topic t
JOIN topic_type tt ON t.topic_type_id = tt.id
WHERE t.specialty_id = 1
  AND t.enabled = true
  AND t.academy_id = 1
ORDER BY t.topic_name;
```

### 3. Verificar Acceso de Usuario a Contenido

```sql
-- Verificar si un usuario puede acceder a un topic
SELECT
    u.id as user_id,
    u.username,
    t.id as topic_id,
    t.topic_name,
    s.name as specialty_name,
    CASE
        WHEN t.specialty_id IS NULL THEN true  -- Contenido compartido
        WHEN t.specialty_id = u.specialty_id THEN true  -- Misma especialidad
        ELSE false  -- No tiene acceso
    END as has_access
FROM users u
CROSS JOIN topic t
LEFT JOIN specialties s ON s.id = t.specialty_id
WHERE u.id = ?
  AND t.academy_id = u.academy_id;
```

### 4. Obtener Membresías Disponibles para una Especialidad

```sql
SELECT
    ml.id,
    ml.name,
    ml.description,
    ml.price_eur,
    ml.access_level,
    s.name as specialty_name,
    CASE
        WHEN ml.specialty_id IS NULL THEN 'General'
        ELSE s.name
    END as applicable_to
FROM membership_levels ml
LEFT JOIN specialties s ON s.id = ml.specialty_id
WHERE (ml.specialty_id = 1 OR ml.specialty_id IS NULL)
  AND ml.is_active = true
ORDER BY ml.access_level DESC, ml.display_order;
```

### 5. Estadísticas por Especialidad

```sql
SELECT
    a.name as academia,
    s.name as especialidad,
    COUNT(DISTINCT u.id) as total_usuarios,
    COUNT(DISTINCT t.id) as total_topics,
    COUNT(DISTINCT q.id) as total_preguntas,
    COUNT(DISTINCT ml.id) as total_membresias
FROM academies a
LEFT JOIN specialties s ON s.academy_id = a.id
LEFT JOIN users u ON u.specialty_id = s.id
LEFT JOIN topic t ON t.specialty_id = s.id
LEFT JOIN questions q ON q.topic = t.id
LEFT JOIN membership_levels ml ON ml.specialty_id = s.id
WHERE a.id = 1
  AND s.is_active = true
GROUP BY a.id, a.name, s.id, s.name
ORDER BY s.display_order;
```

## Migración de Datos Existentes

### Paso 1: Crear Especialidades por Defecto

```sql
-- Crear especialidad por defecto para cada academia
INSERT INTO specialties (academy_id, name, slug, description, is_default, is_active)
SELECT
    id,
    'General',
    'general',
    'Especialidad general de ' || name,
    true,
    true
FROM academies
WHERE is_active = true;
```

### Paso 2: Asignar Topics a Especialidad General

```sql
-- Asignar todos los topics existentes a la especialidad general de su academia
UPDATE topic t
SET specialty_id = s.id
FROM specialties s
WHERE t.academy_id = s.academy_id
  AND s.is_default = true
  AND t.specialty_id IS NULL;
```

### Paso 3: Asignar Usuarios a Especialidad General

```sql
-- Asignar todos los usuarios existentes a la especialidad general de su academia
UPDATE users u
SET specialty_id = s.id
FROM specialties s
WHERE u.academy_id = s.academy_id
  AND s.is_default = true
  AND u.specialty_id IS NULL;
```

## Flujo de la Aplicación

### 1. Onboarding de Usuario

```
Usuario se registra
  → Se crea en auth.users
  → Trigger crea cms_users con academy_id = 1
  → Trigger asigna specialty_id por defecto (si existe)
  → Usuario selecciona especialidad (opcional)
  → Se actualiza users.specialty_id
  → Usuario ve contenido de su especialidad
```

### 2. Selección de Especialidad

```dart
// Flutter - Pantalla de selección de especialidad
class SpecialtySelectionScreen extends StatelessWidget {
  Future<List<Specialty>> fetchSpecialties() async {
    final response = await supabase
      .from('specialties')
      .select('id, name, description, icon_url, color_hex')
      .eq('academy_id', currentUser.academyId)
      .eq('is_active', true)
      .order('display_order');

    return response.map((s) => Specialty.fromJson(s)).toList();
  }

  Future<void> selectSpecialty(int specialtyId) async {
    await supabase
      .from('users')
      .update({'specialty_id': specialtyId})
      .eq('id', currentUser.id);

    // Recargar contenido
    navigateToHome();
  }
}
```

### 3. Filtrado Automático de Contenido

```dart
// Repositorio - Obtener topics
Future<List<Topic>> getTopics() async {
  final user = await getCurrentUser();

  return supabase
    .from('topic')
    .select('*, topic_type(*)')
    .eq('academy_id', user.academyId)
    .or('specialty_id.is.null,specialty_id.eq.${user.specialtyId}')
    .eq('enabled', true)
    .order('topic_name');
}
```

### 4. Sistema de Membresías por Especialidad

```dart
// Verificar acceso premium a especialidad
Future<bool> hasPremiumAccess(int topicId) async {
  final user = await getCurrentUser();

  // Obtener topic con su especialidad
  final topic = await supabase
    .from('topic')
    .select('*, specialties(*)')
    .eq('id', topicId)
    .single();

  // Si no es premium, permitir acceso
  if (!topic.isPremium) return true;

  // Verificar si tiene membresía activa
  final memberships = await supabase
    .from('user_memberships')
    .select('*, membership_levels(*)')
    .eq('user_id', user.id)
    .eq('status', 'active')
    .gte('expires_at', DateTime.now().toIso8601String());

  // Verificar si alguna membresía cubre esta especialidad
  for (var membership in memberships) {
    final level = membership.membershipLevels;
    // Membresía general O membresía de la especialidad específica
    if (level.specialtyId == null ||
        level.specialtyId == topic.specialtyId) {
      return true;
    }
  }

  return false;
}
```

## Consideraciones de Diseño

### 1. Contenido Compartido vs Específico

- **Contenido Compartido**: `specialty_id = NULL`
  - Visible para todos los usuarios de la academia
  - Ej: Topics generales, recursos comunes

- **Contenido Específico**: `specialty_id = ID`
  - Solo visible para usuarios de esa especialidad
  - Ej: Topics especializados, preguntas específicas

### 2. Membresías Flexibles

- **Membresía General**: Desbloquea todo el contenido premium de la academia
- **Membresía Específica**: Desbloquea solo contenido premium de una especialidad
- Un usuario puede tener múltiples membresías activas

### 3. Gestión de Editores

- Los editores (`cms_users`) tienen acceso completo a su academia
- No hay restricción por especialidades para editores
- El control de acceso se hace a nivel de academia (`academy_id`)

### 4. Migración Gradual

- Las especialidades son **opcionales**
- Contenido existente funciona con `specialty_id = NULL`
- Migración progresiva sin romper funcionalidad

## Índices Recomendados

```sql
-- Búsquedas principales
CREATE INDEX idx_specialties_academy_active ON specialties(academy_id, is_active);
CREATE INDEX idx_users_academy_specialty ON users(academy_id, specialty_id);
CREATE INDEX idx_topic_academy_specialty ON topic(academy_id, specialty_id);
CREATE INDEX idx_membership_specialty_active ON membership_levels(specialty_id, is_active);

-- Búsquedas compuestas
CREATE INDEX idx_topic_specialty_enabled ON topic(specialty_id, enabled) WHERE enabled = true;
CREATE INDEX idx_topic_specialty_premium ON topic(specialty_id, is_premium) WHERE is_premium = true;

-- Búsqueda por slug
CREATE INDEX idx_specialties_slug ON specialties(academy_id, slug);
```

## Resumen

✅ **Especialidades** añaden jerarquía flexible entre academia y contenido
✅ Cada especialidad tiene su propio contenido, usuarios y membresías
✅ Contenido puede ser compartido (specialty_id = NULL) o específico
✅ Sistema de membresías premium por especialidad
✅ Editores NO están limitados por especialidades (acceso total a la academia)
✅ Migración gradual sin romper funcionalidad existente
✅ Triggers automáticos para asignación por defecto
✅ Validaciones para mantener integridad de datos

---

**Documentación generada**: 2025-10-27
**Sistema**: OPN Test Guardia Civil
**Versión**: Sistema de Especialidades v1.0